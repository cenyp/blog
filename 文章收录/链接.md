# [对象解构成数组](https://juejin.cn/post/7374308419074146313#heading-4)
```js
// 通过给对象添加属性来实现，同for of 遍历原理
Object.prototype[Symbol.iterator] = function(){
    return Object.values(this)[Symbol.iterator]()
}
let [a,b] = {a:1,b:2} // [1, 2]

```

# [Map的时间复杂度是多少](https://juejin.cn/post/7374685303884562484#heading-14)

面试官问map的时间复杂度一般是想问hash表的冲突问题，map的时间复杂度主要取决于其具体实现方式。在理想情况下，如果能够将键均匀分布在整个哈希表中，避免冲突，那么map的查找、插入和删除操作的时间复杂度可以达到O(1)，即常数时间复杂度。然而，如果哈希函数导致很多键落在同一个桶中，形成链表或红黑树，如果是链表的时间复杂度将退化为O(n)，其中n是链表或树中的条目数量，如果是红黑树那么就是O(logn)

一般讨论map的获取复杂度就是讨论第一层的，难道object就没有第二层了？面试官要问的明显就是hash冲突的问题，但是js的map和object没有实现标准，具体实现都看具体的引擎是怎么实现的。常见的hash冲突就是用链表，然后太长了就用红黑树，所以不冲突复杂度是O1，冲突了变成链表就是On，太长了变成红黑树就是Ologn

哈希表：就是通过计算key对应的hash来判断内存地址，从而获取value，所以值是o1

# [Web 中的“选区”和“光标”](https://juejin.cn/post/7068232010304585741)
主要对可编辑元素（input 和 textarea）和普通元素的内容选中操作，可以应用于多平台的复制方法（兼容mac），文本选中修改等等

# [纯 CSS 也能实现拖拽效果？](https://juejin.cn/post/6933016266365992974)
利用 css 实现 h5 页面的悬浮按钮拖拽吸附功能，可以学习，建议还是利用 js 实现

# [谈谈JS二进制：File、Blob、FileReader、ArrayBuffer、Base64](https://zhuanlan.zhihu.com/p/568915443)
[js二进制及其相关转换全总结](https://juejin.cn/post/7395866692798201871)

详细地讲述了前端关于文件操作的相关事项

# [三种虚拟列表原理与实现](https://juejin.cn/post/7232856799170805820?searchId=20240703181150A4BFBFCDAB5353255527)
固定高度：计算总高度设置到子节点，让子节点可以滚动。根据子节点的scrollTop/单项高度确定滚动位置，进行渲染。注意要前后预留缓冲区

不固定高度：
- 预设一个高度进行计算，渲染完成用真实高度进行替换
- 记录所有节点的高度，总高度设置一个足够大的值即可

# [一文彻底学会使用web worker](https://juejin.cn/post/7139718200177983524)
讲述了
1. webworker 创建、通讯、监听和关闭
2. 引用其他js文件
3. ESModule 模式
4. 可以传递的数据类型
5. SharedWorker 跨页面通讯
6. 兼容性

# [js的沙箱环境](https://juejin.cn/post/7346865556328644623)
1. 沙箱使用环境
2. 沙箱的多种实现（iframe/webworkers/with + new Function）

# [git规范于变基](https://juejin.cn/post/7389650358539255845)
1. 记录了 git pull 与 rebase（变基）的区别

# [纯 CSS 实现的的3种扫光效果](https://juejin.cn/post/7385935890931712019)
记录了文本、规则图片和不规则图片的扫光效果实现

# [「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214)
两种垃圾回收策略：1.标记清除算法 2.引用计数算法

V8对GC的优化：使用的也是标记清除算法，把内存分区成新生代（使用区和空闲区（还会互换））和老生代（对不同区域的内存做不同方式处理，加快回收效率）

并行回收：通过辅助线程（多线程）来加快回收速度，避免全停顿（单线程弊端，回收时不能干别的事情）

增量标记：利用三色标记法（白、灰、黑代表没有标记到自身和成员都标记）；利用写屏障处理新变量引用修改避免被回收（a->b改成a->c【白色】，c还没有被标记）

懒性清理：对于有足够内存来运行程序，可以先执行程序，再逐步清理内存，再进行标记

并发回收：完全避免并行回收里面的停顿，主线程也可以自由执行而不会被挂起

老生代垃圾回收器中这几种策略都是融合使用的：
1. 老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成），主线程上使用增量标记，并且开启多个线程进行并发标记
2. 标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）
3. 同时，清理的任务会采用增量的方式分批在各个 JavaScript 任务之间执行

# [我眼中的几个神力般的WebAPI](https://juejin.cn/post/7403758419361202239)
1. MutationObserver 监听 dom 变化
2. PerformanceObserver 观测性能事件，最主要的应用场景就是网页性能统计
3. IntersectionObserver 观察目标元素与文档可视窗口的交叉变化

# [最全 ECMAScript 攻略](https://juejin.cn/post/6968269593206849572)
整理了各个版本的规范和新加 api

> 在日常开发中，还是得多问 AI，可以解锁很多不常用的 api，当然还是要辩证地使用

# [会js的你怎么可以不会ts呢(ts知识点整理)](https://juejin.cn/post/7416272705513685001)
