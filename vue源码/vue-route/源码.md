参考文章链接
https://juejin.cn/post/6880529850159874062#heading-11

https://juejin.cn/post/6901047675227996167

https://juejin.cn/post/6902992939115855880

# push 如何实现路由切换

以 history 模式为例，源码大概实现如下；可以看到是调用了 transitionTo 方法来做路由页面的切换，pushState 方法处理页面栈，handleScroll 方法处理页面滚动

```js
push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    const { current: fromRoute } = this
    this.transitionTo(location, route => {
      pushState(cleanPath(this.base + route.fullPath))
      handleScroll(this.router, route, fromRoute, false)
      onComplete && onComplete(route)
    }, onAbort)
  }
```

其中 pushState 实现如下，主要时利用 replaceState、pushState 方法来处理路由栈。

```js
if (replace) {
    history.replaceState({ key: _key }, '', url)
} else {
    _key = genKey()
    history.pushState({ key: _key }, '', url)
}

// hash 也是同样调用上面的方法
function pushHash(path) {
    if (supportsPushState) {
        pushState(getUrl(path))
    } else {
        window.location.hash = path
    }
}

// 替换hash记录
function replaceHash(path) {
    if (supportsPushState) {
        replaceState(getUrl(path))
    } else {
        window.location.replace(getUrl(path))
    }
}
```

supportsPushState 判断浏览器是否支持 pushState，不支持则使用 hash 模式

```js
export const supportsPushState =
    inBrowser &&
    (function () {
        const ua = window.navigator.userAgent

        if (
            (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
            ua.indexOf('Mobile Safari') !== -1 &&
            ua.indexOf('Chrome') === -1 &&
            ua.indexOf('Windows Phone') === -1
        ) {
            return false
        }

        return window.history && 'pushState' in window.history
    })()
```

回到 transitionTo，主要是做了路由组件的切换，和路由数据的更新，以及路由守卫的触发。

confirmTransition，主要根据 url 变化，处理所有要触发的路由守卫，可以参考 https://juejin.cn/post/6901047675227996167#heading-12，不细说

```js
  transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    // 获取路由信息
    const route = this.router.match(location, this.current)
    this.confirmTransition(route, () => {
      // 触发路由守卫
      this.updateRoute(route)
      onComplete && onComplete(route)
      // 修改路由栈
      this.ensureURL()

      // fire ready cbs once
      if (!this.ready) {
        this.ready = true
        this.readyCbs.forEach(cb => { cb(route) })
      }
    }, err => {
      if (onAbort) {
        onAbort(err)
      }
      if (err && !this.ready) {
        this.ready = true
        this.readyErrorCbs.forEach(cb => { cb(err) })
      }
    })
  }
```

# 用户后退前进行为监听

像 history 是用 popstate 进行监听，而 hash 也是优先使用 popstate，在不支持的浏览器才使用 hashchange

对于 replaceState、pushState 是不会触发二者的监听行为的

而 window.location.hash 和 window.location.replace 会触发上述的监听导致路由切换

所以，hash 和 history 模式在使用上有不同，但底层往往是一致的，除了在不支持 popstate 浏览器上
